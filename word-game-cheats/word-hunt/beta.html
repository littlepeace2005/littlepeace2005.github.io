<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Word Bites Helper</title>
<style>
  :root {
    --bg:#0b0f14; --panel:#121821; --muted:#8aa0b4; --ink:#dbe7f4;
    --accent:#6fd3ff; --hit:#60ffa7; --danger:#ff6b81;
  }
  * { box-sizing:border-box; }
  html, body { height:100%; }
  body {
    margin:0;
    font:15px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    color:var(--ink);
    background:linear-gradient(180deg,#0b0f14,#0a1018 60%,#0b0f14);
    display:flex;
    justify-content:center;
    align-items:flex-start;
    min-height:600px;
    height:100vh;
    padding:20px;
  }
  .app {
    width:min(1000px,100%);
    display:flex;
    flex-direction:column;
    gap:14px;
    height:100%;
  }
  header { display:flex; justify-content:space-between; align-items:center; }
  .title { font-size:20px; font-weight:700; }
  .hint { color:var(--muted); font-size:13.5px; }
  .kbd {
    display:inline-grid; place-items:center;
    padding:.1rem .4rem; border-radius:5px;
    background:#0e1620; border:1px solid #223042;
    color:#c9d8e6; font-size:11px;
  }

  .row { display:flex; gap:14px; align-items:stretch; flex:1; min-height:0; }
  @media (max-width:820px){ .row{flex-direction:column;} }

  .card {
    background:var(--panel);
    border:1px solid #1b2430;
    border-radius:14px;
    padding:14px;
    box-shadow:0 6px 20px rgba(0,0,0,.35);
    display:flex;flex-direction:column;justify-content:space-between;
    min-height:0;
  }

  .controls {
    flex:0 0 290px;
    display:flex;flex-direction:column;justify-content:space-between;
  }

  label { font-size:13.5px;color:var(--muted);display:block;margin-bottom:6px; }
  .gridInput {
    display:grid;
    grid-template-columns:repeat(8,38px);
    grid-auto-rows:38px;
    justify-content:start;
    column-gap:4px; row-gap:4px; margin-top:4px;
  }
  .gridCell {
    width:38px;height:38px;display:flex;align-items:center;justify-content:center;
    border-radius:8px;background:#0f141c;border:1px solid #203040;
    font-size:20px;font-weight:700;text-transform:uppercase;
    cursor:pointer;
  }
  .gridCell.cursor {
    border-color:var(--accent);
    box-shadow:0 0 0 1px rgba(111,211,255,.6);
  }
  .gridCell.empty {
    color:#364760;
  }

  .btn {
    cursor:pointer;border:0;padding:9px 10px;border-radius:10px;
    font-weight:650;font-size:14px;color:#03111a;
    background:linear-gradient(180deg,#89e3ff,#48c7ff);
    box-shadow:0 6px 18px rgba(64,200,255,.35);
    width:100%;
  }
  .btn.secondary {
    background:#1a2736;color:var(--ink);
    border:1px solid #2a3a4f;box-shadow:none;
  }
  .btn.small {
    font-size:12px;
    padding:6px 8px;
    margin-top:6px;
  }
  .btn:disabled {
    opacity:.5;cursor:not-allowed;box-shadow:none;
  }

  .btnGrid {
    display:grid;
    grid-template-columns:repeat(2,1fr);
    gap:8px;
    margin-top:12px;
  }

  .pill {
    padding:.1rem .6rem;border:1px solid #254057;
    border-radius:999px;color:#a9c6dc;font-size:12px;
    white-space:nowrap;
  }
  .pill.bad { border-color:rgba(255,107,129,.7);color:#ffd1d9; }

  .legend { display:flex;gap:8px;align-items:center;font-size:12px;color:var(--muted); }
  .legend i { display:inline-block;width:9px;height:9px;border-radius:50%; }
  .legend .word { background:var(--accent); }
  .legend .moved { background:var(--hit); }
  .legend .ghost { background:rgba(111,211,255,.3); }

  .gridCard {
    flex:2 1 520px;
    display:flex;flex-direction:column;justify-content:space-between;
    min-height:0;
    gap:8px;
  }
  .svgWrap {
    flex:1;
    width:100%;
    min-height:320px;
    border-radius:12px;
    background:#0b1118;
    border:1px solid #1a2431;
    overflow:hidden;
  }
  svg { width:100%;height:100%;display:block; }

  .footer { color:#8ea7bb;font-size:13.5px;margin-top:4px;text-align:center; }
  .bottomHint { color:var(--muted);font-size:13.5px;margin-top:6px; }

  .steps {
    max-height:190px;
    overflow:auto;
    padding:8px 10px;
    border-radius:10px;
    background:#0c131d;
    border:1px solid #1b2838;
    font-size:13px;
  }
  .steps h3 {
    margin:0 0 4px 0;
    font-size:13px;
    color:#a9c6dc;
  }
  .steps ol {
    margin:4px 0 0 18px;
    padding:0;
  }
  .steps li { margin-bottom:2px; }

  @media (max-width:820px){
    .controls{flex:0 0 auto;}
    .gridCard{
      flex:0 0 auto;
    }
    .svgWrap{
      flex:unset;
      aspect-ratio:8/9;
      width:100%;
      min-height:280px;
      max-height:60vh;
    }
  }
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="title">Word Bites Helper</div>
    <div class="hint">
      <span class="kbd">↑↓←→</span> 移动光标，
      字母键填当前格，
      <span class="kbd">Space</span>/<span class="kbd">Backspace</span>/<span class="kbd">Enter</span> 清当前格，
      点击 <strong>Search</strong> 或 <span class="kbd">Ctrl</span>+<span class="kbd">Enter</span> 搜索，
      <span class="kbd">Ctrl</span>+<span class="kbd">←/→</span> 换方案
    </div>
  </header>

  <div class="row">
    <section class="card controls">
      <div>
        <label>8×9 棋盘输入（8 列 × 9 行，空格 = 没有字母）</label>
        <div class="gridInput" id="gridInput"></div>
      </div>

      <div style="display:flex;flex-direction:column;margin-top:14px;">
        <div class="btnGrid">
          <button id="runBtn" class="btn">Search</button>
          <button id="clearBtn" class="btn secondary">Clear</button>
          <button id="prevBtn" class="btn secondary">⏮ Prev</button>
          <button id="nextBtn" class="btn secondary">Next ⏭</button>
        </div>
        <div class="bottomHint">
          请将 <code>scrabble_words.txt</code> 放在同目录下，页面加载时自动读取字典。
        </div>
      </div>
    </section>

    <section class="card gridCard">
      <div style="display:flex;align-items:center;justify-content:space-between;color:var(--muted);margin-bottom:4px;gap:8px;">
        <div class="pill" id="status">Loading dictionary...</div>
        <div class="legend">
          <i class="word"></i><span>单词所在格</span>
          <i class="moved"></i><span>移动后格</span>
          <i class="ghost"></i><span>上一步位置</span>
        </div>
      </div>

      <div class="svgWrap"><svg id="board" viewBox="0 0 520 520" preserveAspectRatio="xMidYMid meet"></svg></div>

      <div class="steps" id="steps">
        <h3>步骤 / Steps</h3>
        <div>输入棋盘并点击 Search 或按 Ctrl+Enter 搜索方案。</div>
      </div>

      <div class="footer">
        当前方案：<span id="solutionLabel">0 / 0</span>
      </div>
    </section>
  </div>
</div>

<script>
/* ========= 棋盘尺寸：8 列 × 9 行 ========= */
const W = 8;   // columns
const H = 9;   // rows

const el = id => document.getElementById(id);

let lettersArr = Array(W * H).fill('');   // 一维：行优先
let cursorIndex = 0;

let dict = [];
let dictLoaded = false;

let solutions = [];
let activeSolutionIndex = -1;

const boardSvg = el('board');
const statusPill = el('status');
const gridInput = el('gridInput');
const stepsBox = el('steps');
const solutionLabel = el('solutionLabel');

/* ========= 初始化输入网格 ========= */
function createGrid() {
  gridInput.innerHTML = '';
  for (let i = 0; i < W * H; i++) {
    const cell = document.createElement('div');
    cell.className = 'gridCell empty';
    cell.dataset.index = i;
    cell.addEventListener('click', () => {
      cursorIndex = i;
      updateGrid();
    });
    gridInput.appendChild(cell);
  }
}
createGrid();

function updateGrid() {
  const cells = gridInput.children;
  for (let i = 0; i < cells.length; i++) {
    const c = cells[i];
    const ch = lettersArr[i] || '';
    c.textContent = ch;
    c.classList.toggle('cursor', i === cursorIndex);
    c.classList.toggle('empty', !ch);
  }
}

/* ========= 键盘输入逻辑 ========= */
function moveCursor(dr, dc) {
  let r = Math.floor(cursorIndex / W);
  let c = cursorIndex % W;
  r = Math.min(H - 1, Math.max(0, r + dr));
  c = Math.min(W - 1, Math.max(0, c + dc));
  cursorIndex = r * W + c;
  updateGrid();
}

document.addEventListener('keydown', (e) => {
  // Ctrl+左右：切方案
  if (e.ctrlKey && e.key === 'ArrowRight') {
    e.preventDefault();
    nextSolution();
    return;
  }
  if (e.ctrlKey && e.key === 'ArrowLeft') {
    e.preventDefault();
    prevSolution();
    return;
  }

  // Ctrl+Enter：搜索
  if (e.ctrlKey && e.key === 'Enter') {
    e.preventDefault();
    runSearch();
    return;
  }

  // 方向键：移动光标
  if (e.key === 'ArrowUp') { e.preventDefault(); moveCursor(-1, 0); return; }
  if (e.key === 'ArrowDown') { e.preventDefault(); moveCursor(1, 0); return; }
  if (e.key === 'ArrowLeft') { e.preventDefault(); moveCursor(0, -1); return; }
  if (e.key === 'ArrowRight') { e.preventDefault(); moveCursor(0, 1); return; }

  // Enter / 空格 / Backspace：只清当前格（如果有字母），光标不动
  if (e.key === 'Enter' || e.key === ' ' || e.key === 'Backspace') {
    e.preventDefault();
    if (lettersArr[cursorIndex]) {
      lettersArr[cursorIndex] = '';
      updateGrid();
    }
    return;
  }

  // 字母：写入当前格，不挪光标
  if (e.key.length === 1 && /[a-zA-Z]/.test(e.key)) {
    e.preventDefault();
    lettersArr[cursorIndex] = e.key.toUpperCase();
    updateGrid();
    return;
  }
});

/* ========= 读当前棋盘到二维数组 ========= */
function getGridLetters2D() {
  const grid = [];
  for (let r = 0; r < H; r++) {
    const row = [];
    for (let c = 0; c < W; c++) {
      const ch = lettersArr[r * W + c] || '';
      row.push(ch);
    }
    grid.push(row);
  }
  return grid;
}

/* ========= 识别 Word Bites 方块（连通块 ≤2 且直线） ========= */
function buildBlocksFromGrid(grid) {
  const visited = Array.from({ length: H }, () => Array(W).fill(false));
  const blocks = [];
  const blocksByLetters = new Map();
  let totalLetters = 0;

  const inBounds = (r, c) => r >= 0 && r < H && c >= 0 && c < W;

  for (let r = 0; r < H; r++) {
    for (let c = 0; c < W; c++) {
      if (visited[r][c]) continue;
      const ch = grid[r][c];
      if (!ch) continue;

      // BFS 找连通块
      const q = [[r, c]];
      visited[r][c] = true;
      const cells = [];

      while (q.length) {
        const [cr, cc] = q.shift();
        cells.push({ r: cr, c: cc });
        const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
        for (const [dr, dc] of dirs) {
          const nr = cr + dr, nc = cc + dc;
          if (!inBounds(nr, nc) || visited[nr][nc]) continue;
          if (!grid[nr][nc]) continue;
          visited[nr][nc] = true;
          q.push([nr, nc]);
        }
      }

      if (cells.length > 2) {
        throw new Error('检测到一个包含 ' + cells.length + ' 格的连通块（>2），不符合 Word Bites 方块规则。');
      }

      let orientation = 'S'; // 单格
      if (cells.length === 2) {
        const [a, b] = cells;
        if (a.r === b.r) orientation = 'H';
        else if (a.c === b.c) orientation = 'V';
        else throw new Error('检测到非直线形方块（像 L 字），不符合 Word Bites 方块规则。');
      }

      // 按读字顺序排序
      let sortedCells;
      if (orientation === 'H') {
        sortedCells = cells.slice().sort((p, q2) => p.c - q2.c || p.r - q2.r);
      } else if (orientation === 'V') {
        sortedCells = cells.slice().sort((p, q2) => p.r - q2.r || p.c - q2.c);
      } else {
        sortedCells = cells.slice();
      }

      let letters = '';
      for (const { r: rr, c: cc } of sortedCells) {
        letters += grid[rr][cc].toLowerCase();
      }

      const block = {
        id: blocks.length,
        letters,
        orientation,   // 'H' / 'V' / 'S'
        cells: sortedCells
      };
      blocks.push(block);
      totalLetters += letters.length;

      if (!blocksByLetters.has(letters)) blocksByLetters.set(letters, []);
      blocksByLetters.get(letters).push(block.id);
    }
  }

  return { blocks, blocksByLetters, totalLetters };
}

/* ========= 字母统计，用于剪枝 ========= */
function computeLetterCounts(blocks) {
  const counts = {};
  for (const b of blocks) {
    for (const ch of b.letters) {
      counts[ch] = (counts[ch] || 0) + 1;
    }
  }
  return counts;
}

/* ========= 用方块多重集合判断一个单词是否可拼（不看位置/方向） ========= */
function findSegmentation(word, tileTypes, totalLetters, letterCounts) {
  const w = word.toLowerCase();
  if (w.length < 3) return null;
  const maxLen = Math.max(W, H);
  if (w.length > maxLen) return null;

  const localCounts = {};
  for (const ch of w) {
    localCounts[ch] = (localCounts[ch] || 0) + 1;
  }
  for (const ch in localCounts) {
    if (localCounts[ch] > (letterCounts[ch] || 0)) return null;
  }

  const typeCount = tileTypes.length;
  const counts = tileTypes.map(t => t.count);
  const resIndices = [];
  const memo = new Map();

  function dfs(pos) {
    if (pos === w.length) return true;
    const key = pos + '|' + counts.join(',');
    if (memo.has(key)) return false;

    for (let i = 0; i < typeCount; i++) {
      if (counts[i] === 0) continue;
      const tStr = tileTypes[i].str;
      const len = tStr.length;
      if (len > w.length - pos) continue;
      if (w.substr(pos, len) === tStr) {
        counts[i]--;
        resIndices.push(i);
        if (dfs(pos + len)) return true;
        resIndices.pop();
        counts[i]++;
      }
    }
    memo.set(key, false);
    return false;
  }

  const ok = dfs(0);
  if (!ok) return null;
  return resIndices.slice();
}

/* ========= 规划一个单词的最佳摆放（不旋转块） ========= */
function planWord(word, segments, blocks, blocksByLetters) {
  const segCount = segments.length;
  const L = word.length;
  const maxLen = Math.max(W, H);
  if (L > maxLen) return null;

  let best = null;
  const blockCellsSortedCache = {};

  function tryPlacement(dir, fixedIndex) {
    const lineLen = dir === 'H' ? W : H;
    if (L > lineLen) return;
    const maxStart = lineLen - L;

    for (let start = 0; start <= maxStart; start++) {
      const segmentCells = [];
      let offset = 0;

      for (let si = 0; si < segCount; si++) {
        const segLen = segments[si].length;
        const cells = [];
        for (let k = 0; k < segLen; k++) {
          const r = dir === 'H' ? fixedIndex : start + offset + k;
          const c = dir === 'H' ? start + offset + k : fixedIndex;
          cells.push({ r, c });
        }
        segmentCells.push(cells);
        offset += segLen;
      }

      // seg -> 可以“完全不动”就用上的块（同位置、同方向）
      const segToBlocks = segmentCells.map(() => []);

      for (let si = 0; si < segCount; si++) {
        const segStr = segments[si];
        const blockIds = blocksByLetters.get(segStr) || [];
        const targetSorted = segmentCells[si].slice().sort((a, b) => a.r - b.r || a.c - b.c);
        const targetKey = targetSorted.map(p => p.r + ',' + p.c).join(';');

        for (const bId of blockIds) {
          const b = blocks[bId];
          // 横单词不能用竖块，反之同理；单格不受限
          if (segments[si].length > 1) {
            if (dir === 'H' && b.orientation !== 'H') continue;
            if (dir === 'V' && b.orientation !== 'V') continue;
          }

          if (!blockCellsSortedCache[bId]) {
            const sorted = b.cells.slice().sort((a, b2) => a.r - b2.r || a.c - b2.c);
            const key = sorted.map(p => p.r + ',' + p.c).join(';');
            blockCellsSortedCache[bId] = { cells: sorted, key };
          }
          if (blockCellsSortedCache[bId].key === targetKey) {
            segToBlocks[si].push(bId);
          }
        }
      }

      // 尽量多的 segment 用“不动块”
      const matchBlockToSeg = {};
      let stationaryCount = 0;

      function canAssign(segIndex, visitedBlocks) {
        for (const bId of segToBlocks[segIndex]) {
          if (visitedBlocks.has(bId)) continue;
          visitedBlocks.add(bId);
          if (matchBlockToSeg[bId] == null || canAssign(matchBlockToSeg[bId], visitedBlocks)) {
            matchBlockToSeg[bId] = segIndex;
            return true;
          }
        }
        return false;
      }

      for (let si = 0; si < segCount; si++) {
        const visited = new Set();
        if (canAssign(si, visited)) stationaryCount++;
      }

      const baseMoves = segCount - stationaryCount; // 参与单词的块中，需要移动的数量
      if (
        !best ||
        baseMoves < best.baseMoves ||
        (baseMoves === best.baseMoves && word.length > best.wordLength)
      ) {
        const segAssignedBlock = Array(segCount).fill(null);
        for (const bIdStr in matchBlockToSeg) {
          const bId = Number(bIdStr);
          const sIndex = matchBlockToSeg[bId];
          segAssignedBlock[sIndex] = bId;
        }
        best = {
          baseMoves,
          direction: dir,
          fixedIndex,
          start,
          segmentCells,
          segAssignedBlock,
          wordLength: word.length
        };
      }
    }
  }

  for (let row = 0; row < H; row++) tryPlacement('H', row);
  for (let col = 0; col < W; col++) tryPlacement('V', col);

  return best;
}

/* ========= Word Hunt 风格得分（近似 Word Bites） ========= */
function scoreForWordLength(len) {
  const table = {
    3: 100,
    4: 400,
    5: 800,
    6: 1400,
    7: 1800,
    8: 2200,
    9: 2600
  };
  return table[len] || 0;
}

/* ========= 构造完整方案（保证不旋转块 + 考虑腾位置成本） ========= */
function buildSolution(word, segments, bestPlan, blocks, blocksByLetters, initialGrid) {
  const segCount = segments.length;
  const segAssignedBlock = bestPlan.segAssignedBlock;

  const usedBlockIds = new Set();
  const stationaryBlocks = new Set();
  const segBlockId = Array(segCount).fill(null);

  // 已在目标位置的块
  for (let si = 0; si < segCount; si++) {
    const bId = segAssignedBlock[si];
    if (bId != null) {
      segBlockId[si] = bId;
      usedBlockIds.add(bId);
      stationaryBlocks.add(bId);
    }
  }

  // 为剩余 segment 分配需要移动的块（不允许旋转 / 拆块）
  const availableByStr = new Map();
  blocksByLetters.forEach((ids, str) => {
    const remaining = ids.filter(id => !usedBlockIds.has(id));
    availableByStr.set(str, remaining.slice());
  });

  for (let si = 0; si < segCount; si++) {
    if (segBlockId[si] != null) continue;
    const str = segments[si];
    const segLen = str.length;
    const dir = bestPlan.direction; // 'H' | 'V'
    const list = availableByStr.get(str) || [];

    const idx = list.findIndex(bId => {
      const b = blocks[bId];
      if (b.letters.length !== segLen) return false;        // 长度必须一致
      if (segLen > 1) {                                     // 多字母块必须方向一致
        if (dir === 'H' && b.orientation !== 'H') return false;
        if (dir === 'V' && b.orientation !== 'V') return false;
      }
      return true;
    });

    if (idx === -1) continue; // 没有合适块，这个摆法其实不可行（正常不会出现）
    const [bId] = list.splice(idx, 1);
    segBlockId[si] = bId;
    usedBlockIds.add(bId);
  }

  // 记录步骤 + 目标单词格
  const steps = [];
  const wordCells = [];

  for (let si = 0; si < segCount; si++) {
    const bId = segBlockId[si];
    if (bId == null) continue;
    const b = blocks[bId];
    const targetCells = bestPlan.segmentCells[si];
    const fromCells = b.cells;
    const moved = !stationaryBlocks.has(bId);
    steps.push({
      index: si + 1,
      tileStr: b.letters.toUpperCase(),
      moved,
      from: fromCells,
      to: targetCells,
      blockId: bId
    });
    for (const cell of targetCells) wordCells.push({ r: cell.r, c: cell.c });
  }

  // 参与单词的块里，真正要动的数量
  const movedBlockIds = new Set();
  for (const st of steps) {
    if (st.moved) movedBlockIds.add(st.blockId);
  }
  const baseMoves = movedBlockIds.size;

  // 目标单词所有格子
  const targetCellKeys = new Set();
  for (const cells of bestPlan.segmentCells) {
    for (const { r, c } of cells) {
      targetCellKeys.add(r + ',' + c);
    }
  }

  // 计算“挡路的其他块”：它们占了目标格子但不参与当前单词
  const allUsedForWord = new Set(segBlockId.filter(x => x != null));
  const obstacleBlocks = new Set();

  for (const b of blocks) {
    if (allUsedForWord.has(b.id)) continue;
    let touchesTarget = false;
    for (const { r, c } of b.cells) {
      if (targetCellKeys.has(r + ',' + c)) {
        touchesTarget = true;
        break;
      }
    }
    if (touchesTarget) obstacleBlocks.add(b.id);
  }

  const obstacleMoves = obstacleBlocks.size;
  const totalMoves = baseMoves + obstacleMoves;

  // 构造最终棋盘：只把参与单词的块搬到目标位置，其他块保持不变
  const finalGrid = initialGrid.map(row => row.slice());

  // 清掉参与单词块的原位置
  allUsedForWord.forEach(bId => {
    const b = blocks[bId];
    for (const { r, c } of b.cells) {
      finalGrid[r][c] = '';
    }
  });

  // 在目标位置写入单词块
  for (let si = 0; si < segCount; si++) {
    const bId = segBlockId[si];
    if (bId == null) continue;
    const b = blocks[bId];
    const targetCells = bestPlan.segmentCells[si];
    const letters = b.letters.toUpperCase();
    for (let k = 0; k < targetCells.length; k++) {
      const { r, c } = targetCells[k];
      finalGrid[r][c] = letters[k];
    }
  }

  const score = scoreForWordLength(word.length);
  const efficiency = score / (totalMoves + 1);

  return {
    word,
    score,
    direction: bestPlan.direction,
    fixedIndex: bestPlan.fixedIndex,
    start: bestPlan.start,
    steps,
    finalGrid,
    wordCells,
    baseMoves,
    obstacleMoves,
    moves: totalMoves,
    efficiency
  };
}

/* ========= 画棋盘 + 幽灵块 + 箭头 ========= */
function drawBoardWithSolution(grid, wordCells, movedCellsSet, ghostCellsSet, arrows) {
  boardSvg.innerHTML = '';

  const size = 520;
  const pad = 20;
  const cellWidth = (size - 2 * pad) / W;
  const cellHeight = (size - 2 * pad) / H;

  const highlightSet = new Set();
  if (wordCells) {
    for (const { r, c } of wordCells) {
      highlightSet.add(r + ',' + c);
    }
  }

  // 底层格子背景
  for (let r = 0; r < H; r++) {
    for (let c = 0; c < W; c++) {
      const x = pad + c * cellWidth;
      const y = pad + r * cellHeight;
      const key = r + ',' + c;

      let stroke = '#1e2b3b';
      let fill = '#0f1620';

      if (highlightSet.has(key)) {
        stroke = '#6fd3ff';
      }
      if (movedCellsSet && movedCellsSet.has(key)) {
        fill = '#123025';
      }

      const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
      rect.setAttribute('x', x);
      rect.setAttribute('y', y);
      rect.setAttribute('width', cellWidth - 2);
      rect.setAttribute('height', cellHeight - 2);
      rect.setAttribute('rx', 10);
      rect.setAttribute('ry', 10);
      rect.setAttribute('fill', fill);
      rect.setAttribute('stroke', stroke);
      boardSvg.appendChild(rect);
    }
  }

  // 幽灵块（上一位置）
  if (ghostCellsSet && ghostCellsSet.size) {
    ghostCellsSet.forEach(key => {
      const [rStr, cStr] = key.split(',');
      const r = Number(rStr), c = Number(cStr);
      const x = pad + c * cellWidth;
      const y = pad + r * cellHeight;

      const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
      rect.setAttribute('x', x + 3);
      rect.setAttribute('y', y + 3);
      rect.setAttribute('width', cellWidth - 8);
      rect.setAttribute('height', cellHeight - 8);
      rect.setAttribute('rx', 8);
      rect.setAttribute('ry', 8);
      rect.setAttribute('fill', 'rgba(111,211,255,0.08)');
      rect.setAttribute('stroke', 'rgba(111,211,255,0.5)');
      rect.setAttribute('stroke-dasharray', '4 3');
      boardSvg.appendChild(rect);
    });
  }

  // 字母
  for (let r = 0; r < H; r++) {
    for (let c = 0; c < W; c++) {
      const ch = grid[r][c] || '';
      if (!ch) continue;
      const x = pad + c * cellWidth + cellWidth / 2;
      const y = pad + r * cellHeight + cellHeight / 2 + 7;
      const text = document.createElementNS('http://www.w3.org/2000/svg','text');
      text.setAttribute('x', x);
      text.setAttribute('y', y);
      text.setAttribute('text-anchor','middle');
      text.setAttribute('font-size','26');
      text.setAttribute('font-weight','700');
      text.setAttribute('fill','#dbe7f4');
      text.textContent = ch;
      boardSvg.appendChild(text);
    }
  }

  // 箭头（从旧中心 → 新中心）
  if (arrows && arrows.length) {
    const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
    const marker = document.createElementNS('http://www.w3.org/2000/svg','marker');
    marker.setAttribute('id','arrowhead');
    marker.setAttribute('markerWidth','8');
    marker.setAttribute('markerHeight','8');
    marker.setAttribute('refX','4');
    marker.setAttribute('refY','3');
    marker.setAttribute('orient','auto');
    const path = document.createElementNS('http://www.w3.org/2000/svg','path');
    path.setAttribute('d','M0,0 L0,6 L6,3 z');
    path.setAttribute('fill','rgba(111,211,255,0.7)');
    marker.appendChild(path);
    defs.appendChild(marker);
    boardSvg.appendChild(defs);

    for (const ar of arrows) {
      const fromX = pad + (ar.from.c + 0.5) * cellWidth;
      const fromY = pad + (ar.from.r + 0.5) * cellHeight;
      const toX = pad + (ar.to.c + 0.5) * cellWidth;
      const toY = pad + (ar.to.r + 0.5) * cellHeight;

      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1', fromX);
      line.setAttribute('y1', fromY);
      line.setAttribute('x2', toX);
      line.setAttribute('y2', toY);
      line.setAttribute('stroke','rgba(111,211,255,0.7)');
      line.setAttribute('stroke-width','2');
      line.setAttribute('stroke-dasharray','5 4');
      line.setAttribute('marker-end','url(#arrowhead)');
      boardSvg.appendChild(line);
    }
  }
}

/* ========= 更新步骤说明 ========= */
function renderSteps(solution) {
  stepsBox.innerHTML = '';
  const h3 = document.createElement('h3');
  h3.textContent = `单词：${solution.word.toUpperCase()} （得分 ${solution.score}，总移动 ${solution.moves} 块，效率 ${solution.efficiency.toFixed(2)}）`;
  stepsBox.appendChild(h3);

  const info = document.createElement('div');
  const dirText = solution.direction === 'H' ? '水平' : '垂直';
  const lineIndex = solution.fixedIndex + 1;
  info.textContent = `摆放方向：${dirText} · 第 ${lineIndex} 行/列 · 从第 ${solution.start + 1} 格开始`;
  stepsBox.appendChild(info);

  const extra = document.createElement('div');
  extra.style.marginTop = '2px';
  extra.style.fontSize = '12px';
  extra.style.color = '#9ab7cf';
  extra.textContent = `其中 ${solution.baseMoves} 块为单词方块，估计还需额外挪 ${solution.obstacleMoves} 块腾位置。`;
  stepsBox.appendChild(extra);

  const ulTitle = document.createElement('div');
  ulTitle.style.marginTop = '4px';
  ulTitle.textContent = '具体移动步骤（只列出单词对应的块）：';
  stepsBox.appendChild(ulTitle);

  const ol = document.createElement('ol');
  for (const step of solution.steps) {
    const li = document.createElement('li');
    const fromStr = step.from.map(p => `(${p.r+1},${p.c+1})`).join(' ');
    const toStr = step.to.map(p => `(${p.r+1},${p.c+1})`).join(' ');
    if (step.moved) {
      li.textContent = `移动块 "${step.tileStr}"：从 ${fromStr} → 到 ${toStr}`;
    } else {
      li.textContent = `块 "${step.tileStr}" 已在目标位置 ${toStr}，无需移动`;
    }
    ol.appendChild(li);
  }
  stepsBox.appendChild(ol);

  const applyBtn = document.createElement('button');
  applyBtn.className = 'btn small';
  applyBtn.textContent = 'Apply this word to board';
  applyBtn.onclick = applyActiveSolutionToBoard;
  stepsBox.appendChild(applyBtn);
}

/* ========= 显示某个方案 ========= */
function setActiveSolution(idx) {
  if (!solutions.length) {
    activeSolutionIndex = -1;
    solutionLabel.textContent = '0 / 0';
    drawBoardWithSolution(getGridLetters2D(), [], null, null, null);
    stepsBox.innerHTML = '<h3>步骤 / Steps</h3><div>没有方案，请检查棋盘或字典。</div>';
    return;
  }
  activeSolutionIndex = (idx + solutions.length) % solutions.length;
  const s = solutions[activeSolutionIndex];

  const movedCellsSet = new Set();
  const ghostCellsSet = new Set();
  const arrows = [];

  function centerCell(cells) {
    let sumR = 0, sumC = 0;
    for (const p of cells) {
      sumR += p.r; sumC += p.c;
    }
    const n = cells.length || 1;
    return { r: sumR / n, c: sumC / n };
  }

  for (const step of s.steps) {
    if (step.moved) {
      for (const cell of step.to) {
        movedCellsSet.add(cell.r + ',' + cell.c);
      }
      for (const cell of step.from) {
        ghostCellsSet.add(cell.r + ',' + cell.c);
      }
      const fromCenter = centerCell(step.from);
      const toCenter = centerCell(step.to);
      arrows.push({
        from: { r: fromCenter.r, c: fromCenter.c },
        to: { r: toCenter.r, c: toCenter.c }
      });
    }
  }

  drawBoardWithSolution(s.finalGrid, s.wordCells, movedCellsSet, ghostCellsSet, arrows);
  renderSteps(s);
  solutionLabel.textContent = `${activeSolutionIndex + 1} / ${solutions.length}`;
  statusPill.textContent = `Found ${solutions.length} words · 当前：${s.word.toUpperCase()} · ${s.score} 分 · 总移动 ${s.moves} 块`;
  statusPill.classList.remove('bad');
}

/* ========= 上一/下一方案 ========= */
function nextSolution() {
  if (!solutions.length) return;
  setActiveSolution(activeSolutionIndex + 1);
}
function prevSolution() {
  if (!solutions.length) return;
  setActiveSolution(activeSolutionIndex - 1);
}

el('nextBtn').onclick = nextSolution;
el('prevBtn').onclick = prevSolution;

/* ========= 将当前方案应用到棋盘（更新块位置） ========= */
function applyActiveSolutionToBoard() {
  if (activeSolutionIndex < 0 || !solutions.length) return;
  const s = solutions[activeSolutionIndex];
  const grid = s.finalGrid;

  const arr = [];
  for (let r = 0; r < H; r++) {
    for (let c = 0; c < W; c++) {
      arr.push(grid[r][c] || '');
    }
  }
  lettersArr = arr;
  cursorIndex = 0;
  updateGrid();
  drawBoardWithSolution(getGridLetters2D(), [], null, null, null);
  solutions = [];
  activeSolutionIndex = -1;
  solutionLabel.textContent = '0 / 0';
  stepsBox.innerHTML = '<h3>步骤 / Steps</h3><div>已将当前单词应用到棋盘，请再搜索下一步。</div>';
  if (dictLoaded) {
    statusPill.textContent = 'Board updated · Dictionary loaded';
    statusPill.classList.remove('bad');
  }
}

/* ========= 搜索主流程 ========= */
async function runSearch() {
  if (!dictLoaded) {
    alert('Dictionary not loaded yet.');
    return;
  }
  const grid = getGridLetters2D();

  try {
    const { blocks, blocksByLetters, totalLetters } = buildBlocksFromGrid(grid);
    if (!blocks.length) {
      statusPill.textContent = '棋盘上没有任何字母块。';
      statusPill.classList.add('bad');
      return;
    }

    const letterCounts = computeLetterCounts(blocks);

    // tileTypes: {str, count}
    const tileTypes = [];
    blocksByLetters.forEach((ids, str) => {
      tileTypes.push({ str, count: ids.length });
    });

    const candidates = [];
    const maxWordLen = Math.max(W, H);

    for (const w of dict) {
      if (w.length < 3 || w.length > maxWordLen) continue;
      const segIndices = findSegmentation(w, tileTypes, totalLetters, letterCounts);
      if (!segIndices) continue;
      const segments = segIndices.map(i => tileTypes[i].str);
      const bestPlan = planWord(w, segments, blocks, blocksByLetters);
      if (!bestPlan) continue;
      const solution = buildSolution(w, segments, bestPlan, blocks, blocksByLetters, grid);
      candidates.push(solution);
    }

    if (!candidates.length) {
      solutions = [];
      setActiveSolution(-1);
      statusPill.textContent = '没有找到可拼的单词。';
      statusPill.classList.add('bad');
      return;
    }

    // 排序：先按效率（score/(moves+1)）降序，再按总步数升序，再按得分降序
    candidates.sort((a, b) => {
      if (b.efficiency !== a.efficiency) return b.efficiency - a.efficiency;
      if (a.moves !== b.moves) return a.moves - b.moves;
      if (b.score !== a.score) return b.score - a.score;
      return a.word.localeCompare(b.word);
    });

    solutions = candidates;
    setActiveSolution(0);
  } catch (err) {
    console.error(err);
    statusPill.textContent = '错误：' + err.message;
    statusPill.classList.add('bad');
  }
}

/* ========= 按钮事件 ========= */
el('runBtn').onclick = runSearch;
el('clearBtn').onclick = () => {
  lettersArr = Array(W * H).fill('');
  cursorIndex = 0;
  updateGrid();
  drawBoardWithSolution(getGridLetters2D(), [], null, null, null);
  solutions = [];
  activeSolutionIndex = -1;
  solutionLabel.textContent = '0 / 0';
  stepsBox.innerHTML = '<h3>步骤 / Steps</h3><div>已清空棋盘。</div>';
  if (dictLoaded) {
    statusPill.textContent = 'Board cleared · Dictionary loaded';
    statusPill.classList.remove('bad');
  }
};

/* ========= 字典加载 ========= */
async function loadDict() {
  try {
    const res = await fetch('../scrabble_words.txt');
    if (!res.ok) throw new Error('scrabble_words.txt not found');
    const text = await res.text();
    const words = [];
    const maxWordLen = Math.max(W, H);
    for (const line of text.split(/\r?\n/)) {
      const w = line.trim().toLowerCase();
      if (!w) continue;
      if (!/^[a-z]+$/.test(w)) continue;
      if (w.length < 3 || w.length > maxWordLen) continue;
      words.push(w);
    }
    dict = words;
    dictLoaded = true;
    statusPill.textContent = `Dictionary loaded · ${dict.length} words`;
    statusPill.classList.remove('bad');
  } catch (e) {
    statusPill.textContent = '❌ Cannot load scrabble_words.txt';
    statusPill.classList.add('bad');
  }
}

/* ========= 启动 ========= */
updateGrid();
drawBoardWithSolution(getGridLetters2D(), [], null, null, null);
loadDict();
</script>
</body>
</html>
